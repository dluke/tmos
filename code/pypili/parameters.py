
# parameter handling

import os
import xml
import numpy as np
import copy
import collections

"""
todo...
All classes generated by PropertyInterface interface should have setattr overrided
so that it raises an error if the wrong property is assigned to them
"""

# design flaws
# parameter names need to be unique
# i.e. cannot define both args.fire.maxsteps and args.cg.maxsteps
# parameter names need to be spelled perfectly, failing to do so leads to subtle issues

# xml file layout example
"""
<parameters>
<param name=...>
    <default></default>
    <dtype></dtype>
    <form></form>
    <tag>SYSTEM/CELL/PILI/SURFACE<tag>
</param>
.
.
.
</parameters>
"""

### register components 

# AUXILLARY refers to variables which are not independent but depend on other parameters
TAGS = ["system", "fire", "cg", "cell", "pili", "surface", "auxillary"]
# Should make have dummy namspace objects for integrator, system and surface 
# TMOS classes that we must import by name
CPPCLASSES = ["ACell", "Cell3d", "Pili"]

import tmos
from tmos.pili import Pili, ACell, Cell3d

class ParameterError(Exception):
    pass

# metaclass
#https://jakevdp.github.io/blog/2012/12/01/a-primer-on-python-metaclasses/
#https://eli.thegreenplace.net/2011/08/14/python-metaclasses-by-example
class PropertyInterface(type):
    def __new__(cls, name, parents, dct):
        if name in CPPCLASSES:
            dct['klass'] = globals()[name]
        return super(PropertyInterface, cls).__new__(cls, name, parents, dct)

# class containing the various I/O functions and giving access to all parameters
# Let this object replace the args Namespace object

# unfortunately when I define getters and setters with self they end up refering
# to the object they are attached to so for now I pass a reference to params to
# all ParameterInterfaces

# Consider making this object a singleton.
# The only reason it is not a Singleton is to allow analysis routines to create ParameterList 
# objects from multiple files.
class ParameterList(object):

    def __init__(self, params, readonly=False, comment=''):
        """
        params is a dictionary of {name : Parameter()} pairs
        """
        # setup class
        self.params = params
        self.classholders = {}
        # create namespace classes
        for tag in CPPCLASSES + TAGS:
            # define the class
            cppclassholder = PropertyInterface(tag, (), {})
            self.classholders[tag] = cppclassholder
            # an instance of the class
            setattr(self, tag, cppclassholder())

        for name, param in list(params.items()):
            if param.cppclass not in CPPCLASSES:
                proxy = self.classholders[param.tag]
                def local_property(parname):
                    # here we change scope to differentiate parname from name
                    # can be cleaned up ... todo ...
                    def gett(this):
                        return self.params[parname].value
                    def sett(this, v):
                        self.params[parname].value = v
                    return property(gett, sett, doc="Interface to parameter {}".format(parname))
                ppty = local_property(name)
                setattr(proxy, name, ppty)
                #print 'proxy.name', getattr(getattr(self, param.tag), parname)
            else:
                # get and set parameter directly to C++ class
                def cpp_static_property(parname):
                    holderinstance = getattr(self, param.cppclass)
                    def gett(this):
                        return getattr(holderinstance.klass, parname)
                    def sett(this, v):
                        self.params[parname].value = v
                        setattr(holderinstance.klass, parname, v)
                    return property(gett, sett, doc="Interface to c++ static member {} of class {}"
                            .format(name, param.cppclass))
                ppty = cpp_static_property(name)
                proxy = self.classholders[param.cppclass]
                setattr(proxy, name, ppty)

        # # special property eff_k_ret_on
        # def gett(this):
        #     return Pili.eff_k_ret_on
        # def sett(this, eff_k_ret_on):
        #     print("set effective k_ret_on = {} and override k_ret_on".format(eff_k_ret_on))
        #     self.params["eff_k_ret_on"].value = eff_k_ret_on
        #     # self.params["k_ret_on"].value = eff_k_ret_on
        #     Pili.eff_k_ret_on =  eff_k_ret_on
        #     # Pili.k_ret_on = eff_k_ret_on
        #     self.Pili.k_ret_on = eff_k_ret_on # use property
        #     print("set Pili.k_ret_on", Pili.k_ret_on, self.params["k_ret_on"].value)
        # ppty = property(gett, sett, doc="Interface to parameter eff_k_ret_on overrides k_ret_on")
        # proxy = self.classholders["Pili"]
        # setattr(proxy, "eff_k_ret_on", ppty)

        self.comment = comment

        # finished constructing the interface but we still need to set defaults
        if not readonly:
            self.apply()

    def apply(self):
        # transfer default parameter values to CPP model
        for param in list(self.params.values()):
            self.pset(param.name, param.value)
        return self

    def set_comment(self, comm):
        self.comment = comm

    def pset(self, name, value):
        """
        Generic setter. If the parameter has a cppclass holder object make sure we use it.
        """
        param = self.params[name]
        subref = param.cppclass if param.cppclass != None else param.tag
        holderobj = getattr(self, subref)
        setattr(holderobj, name, value)
        param.value = value
        self.params[name] = param

    # convenience getters
    def pget(self, name):
        return self.params[name].value

    def getdtype(self, name):
        return self.params[name].dtype

    def init_generator(self, seed):
        self.pset('seed', seed)
        tmos.base.init_generator(seed)

    def __str__(self):
        st = '---ParameterList---\n'
        st += '#{}\n'.format(self.comment)
        for tag in TAGS:
            st += tag + '\n'
            for param in list(self.params.values()):
                # inefficient
                if param.tag == tag:
                    st += '--> {: <35} {}\n'.format(param.name, param.value)
            st += '\n'
        return st

    @staticmethod
    def parse_str(st):
        """parse the result of str(ParameterList) and reconstruct a parameter object"""
        args = read() # parameter list with defaults
        ist = iter(st.split('\n'))
        assert(next(ist) == '---ParameterList---')
        args.comment = next(ist)[1:]
        for line in ist:
            if not len(line):
                continue # skip empty lines
            if line[:3] == '-->':
                cleanline = line[3:].strip()
                name = cleanline.split()[0]
                s_value = ''.join(cleanline.split()[1:])
                try:
                    val = args.getdtype(name)(s_value)
                    args.pset(name, val)
                except KeyError:
                    print('WARNING: unknown parameter {} in configuration record. This simulation may be from an older version of TMoS'.format(name))
        return args

    @staticmethod
    def parse_config(fc):
        with open(fc, 'r') as fc:
            return ParameterList.parse_str(fc.read())

    def write_config(self, fconfig):
        fconfig.write(str(self))



# The dynamic representation
class Parameter(object):
    def __init__(self, name, dtype, default, units, form, tag, cppclass,
            description, note, symbol):
        self.name = name
        # set both default and current value
        self.default = default
        self.value = default
        #
        self.dtype = dtype
        self.form = form
        self.tag = tag
        self.cppclass = cppclass
        self.units = units
        self.description = description
        self.note = note
        self.isauxillary = False
        self.symbol = symbol

    def __str__(self):
        order = ['default', 'value', 
                'dtype', 'form', 'tag', 
                'cppclass', 'units', 'description',
                'note']
        st = 'Parameter({})\n'.format(self.name)
        for mem in order:
            st += '{: <14} {}\n'.format(mem, getattr(self, mem))
        return st

def parse_paramdata(paramdata):
    """take the path paramaters.xml
    and return a list of fully constructed parameter objects
    """
    import xml.etree.ElementTree
    tree = xml.etree.ElementTree.parse(paramdata)

    params = collections.OrderedDict()
    # defaults
    defdtype = float
    defform = "{:13.8f}"

    # helper functions
    def get_dtype(xparam):
        if xparam.tag == 'param':
            el_dtype = xparam.find('dtype')
            dtype = eval(el_dtype.text) if el_dtype is not None else defdtype
        elif xparam.tag == 'switch':
            #dtype = bool
            dtype = eval
        assert callable(dtype)
        return dtype
    def get_form(xparam):
        if xparam.tag == 'param':
            el_form = xparam.find('form')
            form = el_form.text if el_form is not None else defform
        elif xparam.tag == 'switch':
            form = '{}'
        return form
    def get_units(eledef):
        if 'units' in eledef.attrib:
            units = eledef.attrib['units']
            if units == '': # define empty trings as None
                units = None
        else:
            units = None
        return units

    root = tree.getroot()
    for tag in root:
        tmpparam = {}
        for xparam in tag:
            name = xparam.attrib['name']
            assert(' ' not in name)
            el_cpp = xparam.find('class')
            tmpparam['cppclass'] = el_cpp.text if el_cpp is not None else None
            tmpparam['tag'] = tag.attrib['name']
            tmpparam['form'] = get_form(xparam)
            dtype = get_dtype(xparam)
            tmpparam['dtype'] = dtype
            eledef = xparam.find('default')
            if dtype == bool:
                tmpparam['default'] = eval(eledef.text)
            else:
                tmpparam['default'] = dtype(eledef.text)
            tmpparam['units'] = get_units(eledef)
            tmpparam['description'] = xparam.find('description').text.strip()
            el_note = xparam.find('note')
            tmpparam['note'] = el_note.text.strip() if el_note is not None else ''
            symbol = xparam.find('symbol')
            tmpparam['symbol'] = symbol.text.strip() if symbol is not None else ''
            params[name] = Parameter(name, **tmpparam)

    return params

# convenience
paramdata = os.path.join(os.path.dirname(__file__), 'parameters.xml')
def read():
    params = parse_paramdata(paramdata)
    args = ParameterList(params, readonly=True)
    args.comment = 'default'
    return args

def thisread(cfile = 'config.txt', directory = './'):
    cfile = os.path.join(directory, cfile)
    if os.path.exists(cfile):
        args = ParameterList.parse_config(cfile)
        args.is_default = False
        return args
    else:
        # print("WARNING: parameters.thisread() did not find {}. Continuing with defaults.".format(cfile))
        args = read()
        args.is_default = True
        return args

from tabulate import tabulate
def describe(args, target=[]):
    row = [[args.pget(name) for name in target]]
    if 'anchor_angle_smoothing_fraction' in target: 
        anchor = args.pget('anchor_angle_smoothing_fraction') * np.pi/2
        print("transform anchor parameter onto [0,pi/2] : ", anchor)
    return tabulate(row, headers=target)
        


if __name__=='__main__':

    paramdata = 'parameters.xml'
    params = parse_paramdata(paramdata)
    args = ParameterList(params)

    #print args.params
    #...
    args.Pili.rtau = 9.
    print(args.Pili.rtau)
    print(args.params['rtau'])

    print(args.Cell3d.eps)
    #print args.Cell3d.eps.__get__(args.Cell3d)
    print(args.system)
    print(args.system.simtime)
    print(args.system.repeats)
    print(args.system.dimension)
    print(args.system.vtkwrite)
    #print locals()
